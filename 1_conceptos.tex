% Copyright (C) Rosita Wachenchauzer <rositaw@gmail.com>

% Esta obra está licenciada de forma dual, bajo las licencias Creative
% Commons:
%  * Atribución-Compartir Obras Derivadas Igual 2.5 Argentina
%    http://creativecommons.org/licenses/by-sa/2.5/ar/
%  * Atribución-Compartir Obras Derivadas Igual 3.0 Unported
%    http://creativecommons.org/licenses/by-sa/3.0/deed.es_AR.
%
% A su criterio, puede utilizar una u otra licencia, o las dos.
% Para ver una copia de las licencias, puede visitar los sitios
% mencionados, o enviar una carta a Creative Commons,
% 171 Second Street, Suite 300, San Francisco, California, 94105, USA.

\chapter[Conceptos básicos]{Algunos conceptos básicos}

En esta unidad hablaremos de lo que es un programa de
computadora e introduciremos unos cuantos conceptos referidos a la
programación y a la ejecución de programas. Utilizaremos en todo
momento el lenguaje de programación Python para ilustrar esos
conceptos.

\section{Computadoras y programas}

En la actualidad, la mayoría de nosotros utilizamos computadoras
permanentemente: para mandar correos electrónicos, navegar por Internet,
chatear, jugar, escribir textos.

Las computadoras se usan para actividades tan disímiles como predecir las
condiciones meteorológicas de la próxima semana, guardar historias clínicas,
diseñar aviones, llevar la contabilidad de las empresas o controlar una
fábrica. Y lo interesante aquí (y lo que hace apasionante a esta carrera) es
que el mismo aparato sirve para realizar todas estas actividades: uno no
cambia de computadora cuando se cansa de chatear y quiere jugar al solitario.

Muchos definen una computadora moderna como ``una máquina que
almacena y manipula información bajo el control de un programa que
puede cambiar''. Aparecen acá dos conceptos que son claves: por un
lado se habla de una {\it máquina} que almacena información, y por
el otro lado, esta máquina está controlada por {\it un programa
que puede cambiar}.

Una calculadora sencilla, de esas que sólo tienen 10 teclas para
los dígitos, una tecla para cada una de las 4 operaciones, un
signo igual, encendido y CLEAR, también es una máquina que
almacena información y que está controlada por un programa. Pero
lo que diferencia a esta calculadora de una computadora es que en
la calculadora el programa no puede cambiar.

Un {\it programa de computadora} es un conjunto de {\it
instrucciones} paso a paso que le indican a una computadora cómo
realizar una tarea dada, y en cada momento uno puede elegir
ejecutar un programa de acuerdo a la tarea que quiere realizar.

Las instrucciones se deben escribir en un lenguaje que nuestra
computadora entienda. Los lenguajes de programación son
lenguajes diseñados especialmente para dar
órdenes a una computadora, de manera exacta y no ambigua. Sería
muy agradable poder darle las órdenes a la computadora en
castellano, pero el problema del castellano, y de las lenguas
habladas en general, es su ambigüedad:

Si alguien nos dice {\it ``Comprá el collar sin monedas''}, no sabremos
si nos pide que compremos el collar que no tiene monedas, o que compremos
un collar y que no usemos monedas para la compra. Habrá que preguntarle
a quien nos da la orden cuál es la interpretación correcta. Pero tales
dudas no pueden aparecer cuando se le dan órdenes a una computadora.

Este curso va a tratar precisamente de cómo se escriben programas
para hacer que una computadora realice una determinada tarea.
Vamos a usar un lenguaje específico (Python) porque es sencillo y
elegante, pero éste no será un curso de Python sino un curso de
programación.

\begin{sabias_que}
Existen una gran cantidad de programas desarrollados en Python, desde
herramientas para servidores, como {\bf mailman}, hasta programas amigables
para usuarios finales, como {\bf emesene}, pasando por aplicaciones
empresariales, {\bf openerp}, {\bf tryton}; herramientas de desarrollo,
{\bf meld}, {\bf mercurial}, {\bf bazaar}, {\bf trac}; plataformas web,
{\bf django}, {\bf turbogears}, {\bf zope}; clientes de bittorrent, {\bf
bittorrent}, {\bf bittornado}, {\bf deluge}; montones de juegos de todo
tipo, y muchísimas aplicaciones más.

Todas estas aplicaciones son software libre, por lo que se puede obtener y
estudiar el código con el que están hechas
\end{sabias_que}

\section{El mito de la máquina todopoderosa}

Muchas veces la gente se imagina que con la computadora se puede
hacer cualquier cosa, que no hay tareas imposibles de realizar.
Más aún, se imaginan que si bien hubo cosas que eran imposibles de
realizar hace 50 años, ya no lo son más, o no lo serán dentro de
algunos años, cuando las computadoras crezcan en poder (memoria,
velocidad), y la computadora se vuelva una máquina todopoderosa.

Sin embargo eso no es así: existen algunos problemas, llamados
{\it no computables} que nunca podrán ser resueltos por una
computadora digital, por más poderosa que ésta sea. La
computabilidad es la rama de la computación que se ocupa de
estudiar qué tareas son computables y qué tareas no lo son.

De la mano del mito anterior, viene el mito del lenguaje
todopoderoso: hay problemas que son no computables porque en
realidad se utiliza algún lenguaje que no es el apropiado.

En realidad todas las computadoras pueden resolver los mismos
problemas, y eso es independiente del lenguaje de programación que
se use. Las soluciones a los problemas computables se pueden
escribir en cualquier lenguaje de programación. Eso no significa
que no haya lenguajes más adecuados que otros para la resolución
de determinados problemas, pero la adecuación está relacionada con
temas tales como la elegancia, la velocidad, la facilidad para
describir un problema de manera simple, etc., nunca con la
capacidad de resolución.

Los problemas no computables no son los únicos escollos que se le
presentan a la computación. Hay otros problemas que si bien son
computables demandan para su resolución un esfuerzo enorme en
tiempo y en memoria. Estos problemas se llaman {\it intratables}.
El análisis de algoritmos se ocupa de separar los problemas
tratables de los intratables, encontrar la solución más barata
para resolver un problema dado, y en el caso de los intratables,
resolverlos de manera aproximada: no encontramos la verdadera
solución porque no nos alcanzan los recursos para eso, pero
encontramos una solución bastante buena y que nos insume muchos
menos recursos (el orden de las respuestas de Google a una
búsqueda es un buen ejemplo de una solución aproximada pero no
necesariamente óptima).

En este curso trabajaremos con problemas no sólo computables sino
también tratables. Y aprenderemos a medir los recursos que nos
demanda una solución, y empezaremos a buscar la solución menos
demandante en cada caso particular. \\

Algunos ejemplos de los problemas que encararemos y de sus
soluciones:

\begin{problemac}
Dado un número $N$ se quiere calcular $N^{33}$.
\end{problemac}

Una solución posible, por supuesto, es hacer el producto $N \times
N \times \ldots \times N$, que involucra 32 multiplicaciones.

Otra solución, mucho más eficiente es:
\begin{itemize}
\item Calcular $N \times N$.

\item Al resultado anterior mutiplicarlo por sí mismo con lo cual
ya disponemos de $N^{4}$.

\item Al resultado anterior mutiplicarlo por sí mismo con lo cual
ya disponemos de $N^{8}$.

\item Al resultado anterior mutiplicarlo por sí mismo con lo cual
ya disponemos de $N^{16}$.

\item Al resultado anterior mutiplicarlo por sí mismo con lo cual
ya disponemos de $N^{32}$.

\item Al resultado anterior mutiplicarlo por $N$ con lo cual
conseguimos el resultado deseado con sólo 6 multiplicaciones.

\end{itemize}

Cada una de estas dos soluciones representa un {\it algoritmo}, es
decir un método de cálculo, diferente. Para un mismo problema
puede haber algoritmos diferentes que lo resuelven, cada uno con
un costo distinto en términos de recursos computacionales
involucrados.

\begin{sabias_que}
La palabra \textit{algoritmo} no es una variación de \textit{logaritmo},
sino que proviene de \textit{algorismo}. En la antigüedad, los
\textit{algoristas} eran los que calculaban usando la numeración arábiga y
mientras que los \textit{abacistas} eran los que calculaban usando ábacos.
Con el tiempo el \textit{algorismo} se deformó en \textit{algoritmo},
influenciado por el término \textit{aritmética}.

A su vez el uso de la palabra \textit{algorismo} proviene del nombre de un
matemático persa famoso, en su época y para los estudiosos de esa época,
``Abu Abdallah Muhammad ibn Mûsâ al-Jwârizmî'', que literalmente significa:
``Padre de Ja'far Mohammed, hijo de Moises, nativo de Jiva''. Al-Juarismi,
como se lo llama usualmente, escribió en el año 825 el libro ``Al-Kitâb
al-mukhtasar fî hîsâb al-gabr wa'l-muqâbala'' (Compendio del cálculo por el
método de completado y balanceado), del cual surgió también la palabra
``álgebra''.

Hasta hace no mucho tiempo se utilizaba el término algoritmo para referirse
únicamente a formas de realizar ciertos cálculos, pero con el surgimiento
de la computación, el término algoritmo pasó a abarcar cualquier método
para obtener un resultado.
\end{sabias_que}

\begin{problemac}

Tenemos que permitir la actualización y consulta de una guía
telefónica.

\end{problemac}

Para este problema no hay una solución única: hay muchas y cada
una está relacionada con un contexto de uso. ¿De qué guía estamos
hablando: la guía de una pequeña oficina, un pequeño pueblo, una
gran ciudad, la guía de la Argentina? Y en cada caso ¿de qué tipo
de consulta estamos hablando: hay que imprimir un listado una vez
por mes con la guía completa, se trata de una consulta en línea,
etc.? Para cada contexto hay una solución diferente, con los datos
guardados en una {\it estructura de datos} apropiada, y con
diferentes algoritmos para la actualización y la consulta.

%
% TODO: incluir aunque sea un esbozo de la solución a este problema
%

\section{Cómo darle instrucciones a la máquina usando Python}

\begin{sabias_que}
% TODO: reescribir este cuadro para Python 3.
Python fue creado a finales de los años 80, por un programador holandés
llamado Guido van Rossum, quien sigue siendo aún hoy el líder del
desarrollo del lenguaje.

La versión 2.0, lanzada en 2000, fue un paso muy importante para el
lenguaje ya que era mucho más madura, incluyendo un \textit{recolector de
basura}.  La versión 2.2, lanzada en diciembre de 2001, fue también un hito
importante ya que mejoró la orientación a objetos.  La última versión de
esta línea es la 2.7 que fue lanzada en noviembre de 2010 y aún está vigente.

En diciembre de 2008, se lanzó la rama 3.0, cuya versión actual es la
3.4, de marzo de 2014. Sin embargo, debido a que estas versiones
introducen importantes cambios y no son totalmente compatibles
con las versiones anteriores, todavía no se la utiliza extensamente.
\end{sabias_que}

El lenguaje Python nos provee de un {\it intérprete}, es decir un programa que
interpreta las órdenes que le damos a medida que las escribimos. Para
orientarnos, el intérprete presenta una {\it línea de comandos} (los comandos
son las órdenes) que identifica al comienzo con los símbolos
\lstinline!>>>!, y que
llamaremos {\it prompt}. En esta línea, a continuación del {\it prompt}
podemos escribir diferentes órdenes.

% TODO: no se dice cómo invocar el intérprete; en nuestro caso, “python3”.

Algunas órdenes sencillas, por ejemplo, permiten utilizar la línea de comandos
como una calculadora simple con números enteros. Para esto escribimos la
expresión que queremos resolver en el {\it prompt} y presionamos la tecla
<ENTER>. El intérprete de Python ``responde'' el resultado de la operación en
la línea siguiente, sin {\it prompt}, y luego nos presenta nuevamente el
cursor para escribir la siguiente orden.

\begin{lstlisting}[numbers=none]
>>> 2+3
5
>>>
\end{lstlisting}

Python permite utilizar las operaciones \lstinline!+, -, *, /! y \lstinline!**!
(suma, resta, multiplicación, división y potenciación). La sintaxis es la
convencional (valores intercalados con operaciones), y se pueden usar
paréntesis para modificar el orden de asociación natural de las operaciones
(potenciación, producto/división, suma/resta).

\begin{lstlisting}[numbers=none]
>>> 5*7
35
>>> 2+3*7
23
>>> (2+3)*7
35
>>> 10/4
2.5
>>> 5**2
25
>>>
\end{lstlisting}

Otra orden sencilla de Python permite indicarle al intérprete que escriba o
``imprima'' por pantalla una palabra o frase, que llamaremos {\it cadena de
texto}.

\begin{lstlisting}[numbers=none]
>>> print('Hola')
Hola
>>> print('¿Cómo están?')
¿Cómo están?
>>> print("¡Bienvenidos y bienvenidas a este curso!")
¡Bienvenidos y bienvenidas  a este curso!
>>>
\end{lstlisting}

\lstinline+print+ es una instrucción de Python: aquélla que le indica a la
máquina que debe imprimir un texto en pantalla, que deberá ser ingresado entre
comillas simples \lstinline!'! o dobles \lstinline!"! indistintamente. Ya
veremos con qué otras instrucciones viene equipado Python.

Pero ya dijimos que como programadores debíamos ser capaces de
escribir nuevas instrucciones para la computadora. Los programas
de correo electrónico, navegación por Internet, chat, juegos,
escritura de textos o predicción de las condiciones meteorológicas de los
próximos días no son más que grandes instrucciones que se le dan a la
máquina, escritas por uno o muchos programadores.

Llamaremos {\it función} a una instrucción escrita por un
programador.

Si queremos escribir una función (que llamaremos \lstinline!holaMar!)
que escribe en una línea el texto ``Hola Marta!'' y en la línea
siguiente el texto ``Estoy programando en Python.'', lo que
debemos hacer es ingresar el siguiente conjunto de líneas en
Python:

\begin{codigo}{holaMar}{Saluda a Marta}
\begin{lstlisting}[numbers=none]
>>> def holaMar():
        print("Hola Marta!")
        print("Estoy programando en Python.")

>>>
\end{lstlisting}
\end{codigo}

\lstinline!def holaMar():! le indica a Python que estamos escribiendo
una función cuyo nombre es \lstinline!holaMar!. ¿Por qué se ponen
esos dos paréntesis? Lo veremos dentro de unos párrafos. La
sangría con la que se escriben las dos instrucciones \lstinline+print+
le indican a Python que estamos escribiendo el {\it cuerpo} (es
decir las instrucciones que la componen) de la función en
cuestión. Las dos teclas <ENTER> \esp que tecleamos después de
ingresar el texto \lstinline+"Estoy programando en Python."+ le indican
a Python que se acabó el cuerpo de la función (y por eso aparece
nuevamente el cursor).

Si ahora queremos que la máquina ejecute la función
\lstinline!holaMar!, debemos escribir \lstinline!holaMar()! a continuación
del cursor de Python:

\begin{lstlisting}[numbers=none]
>>> holaMar()
Hola Marta!
Estoy programando en Python.
>>>
\end{lstlisting}

Se dice que estamos {\it invocando} a la función \lstinline!holaMar!.
Al invocar una función, se ejecutan las instrucciones que habíamos
escrito en su cuerpo, una a continuación de la otra.

Nuestro amigo Pablo seguramente se pondrá celoso porque escribimos
una función que la saluda a Marta, y nos pedirá que escribamos una
función que lo salude a él. Y así procederemos entonces:

\begin{codigo}{holaPab}{Saluda a Pablo}
\begin{lstlisting}[numbers=none]
>>> def holaPab():
        print("Hola Pablo!")
        print("Estoy programando en Python.")
\end{lstlisting}
\end{codigo}

Pero, si para cada amigo que quiere que lo saludemos debemos que
escribir una función distinta, parecería que la computadora no es
una gran solución. A continuación veremos, sin embargo, que
podemos llegar a escribir una única función que se personalice en
cada invocación, para saludar a quien queramos. Para eso están
precisamente los paréntesis.

Las funciones tienen partes variables, llamadas {\it parámetros},
que se ponen dentro de los paréntesis. Escribimos por ejemplo una
función \lstinline!hola! general que nos sirva para saludar a
cualquiera, de la siguiente manera:

\begin{codigo}{hola}{Saluda a quien sea necesario}
\begin{lstlisting}[numbers=none]
>>> def hola(alguien):
        print("Hola", alguien, "!")
        print("Estoy programando en Python.")
\end{lstlisting}
\end{codigo}

En este caso, \lstinline!alguien! es un parámetro cuyo valor será reemplazado
por un texto (nombre en este caso) en cada invocación.  Por ejemplo, podemos
invocarla dos veces, para saludar a Ana y a Juan:

\begin{lstlisting}[numbers=none]
>>> hola("Ana")
Hola Ana !
Estoy programando en Python.
>>> hola("Juan")
Hola Juan !
Estoy programando en Python.
>>>
\end{lstlisting}

\begin{problema}
\label{cuad1}
Escribir un programa que calcule el cuadrado de un número dado.
\end{problema}

\begin{solucion}
Para resolver este problema, se combinan los recursos utilizados hasta ahora.

\begin{codigo}{cuad1}{Eleva un número al cuadrado y lo imprime}
\begin{lstlisting}[numbers=none]
def cuad1(num):
        print(num*num)
\end{lstlisting}
\end{codigo}

Para invocarlo, deberemos hacer:
\begin{lstlisting}[numbers=none]
>>> cuad1(5)
25
>>>
\end{lstlisting}
\end{solucion}

\begin{problema}
Permitir que el usuario ingrese el valor a elevar al cuadrado.
\end{problema}

\begin{solucion}
Para esto utilizaremos una nueva función \lstinline+input+ que permite leer
valores ingresados por el usuario. Como el valor ingresado por el usuario debe
de ser un entero, se lo indicamos a Python empleando la notación de conversión
\lstinline+int+.

\begin{codigo}{cuad2}{Pide un número al usuario e imprime su cuadrado}
\begin{lstlisting}[numbers=none]
def cuad2():
        n = int(input("Ingrese un número: "))
        cuad1(n)
\end{lstlisting}
\end{codigo}

La ejecución del programa será la siguiente:

\begin{lstlisting}[numbers=none]
>>> cuad2()
Ingrese un numero: 5
25
>>>
\end{lstlisting}
\end{solucion}

\section{Devolver un resultado}

Las funciones que vimos hasta ahora muestran mensajes,
pero no hemos visto funciones que se comporten como las
funciones que conocemos, las de la matemática, que
se usan para calcular resultados.

Queremos también poder hacer cosas del estilo $y=f(x)$
en nuestros programas.
Para ello introduciremos la instrucción \lstinline!return <expresion>!
que indica cuál es el valor que tiene que devolver nuestra función.

En este ejemplo escribimos una función que eleva al cuadrado un número.

\begin{codigo}{cuadrado}{Eleva un número al cuadrado y lo devuelve}
\label{cuadrado}
\begin{lstlisting}[numbers=none]
>>> def cuadrado (x):
...         cua = x * x
...         return cua
...
>>> y = cuadrado (5)
>>> y
25
>>>
\end{lstlisting}
\end{codigo}

\section{Una instrucción un poco más compleja: el ciclo definido}

\begin{problema}Ahora que sabemos construir una función que calcula el cuadrado de un número,
nos piden que imprimamos los cuadrados de los números del 2 al 8.
\end{problema}

\begin{solucion}
Por supuesto que podemos hacer:
\begin{lstlisting}[numbers=none]
>>> def cuad3():
        print(cuadrado(2))
        print(cuadrado(3))
        print(cuadrado(4))
        print(cuadrado(5))
        print(cuadrado(6))
        print(cuadrado(7))
        print(cuadrado(8))

>>> cuad3()
4
9
16
25
36
49
64
>>>
\end{lstlisting}
\end{solucion}

¿Se puede hacer algo mejor que esto? Con lo que sabemos de Python hasta el momento, no.

Para resolver este tipo de problema (repetir un cálculo para los valores
contenidos en un intervalo dado) de manera eficiente, introducimos el concepto
de {\it ciclo definido}, que tiene la siguiente forma:

\begin{lstlisting}[numbers=none]
for x in range(n1, n2):
	<hacer algo con x>
\end{lstlisting}

Esta instrucción se lee como:

\begin{itemize}
\item Generar la secuencia de valores enteros del intervalo $[n_1, n_2)$, y
\item Para cada uno de los valores enteros que toma \verb+x+ en el intervalo generado,
se debe hacer lo indicado por {\it $<$hacer algo con x$>$}.
\end{itemize}

Vemos cómo, usando esta construcción, el problema anterior se puede resolver
de manera más compacta:

\begin{solucion} En nuestro caso lo que hay que hacer es invocar a la
instrucción \lstinline!print(cuadrado(x))! que usa la función definida en
\ref{cuadrado} para calcular el cuadrado de \lstinline!x!, y luego imprime el
resultado, cuando \lstinline!x! toma los valores $2, 3, \ldots, 8$.

La instrucción que describe qué tipo de repeticiones se deben
realizar es el {\it encabezado del ciclo}, y las instrucciones que
describen la acción que se repite se llaman {\it cuerpo del
ciclo}.

No nos olvidemos que en nuestro ejemplo el ciclo debe recorrer todos los valores
enteros entre 2 y 8, por lo tanto:

\begin{itemize}
\item \lstinline+for x in range(2, 9):+ será el encabezado del ciclo y
\item \lstinline+print(cuadrado(x))+ será el cuerpo del ciclo.
\end{itemize}

Vemos entonces cómo resulta el ciclo completo (con su ejecución):

\begin{codigo}{cuadrados}{Imprime los cuadrados del 2 al 8}
\begin{lstlisting}[numbers=none]
>>> for x in range(2, 9):
        print(cuadrado(x))

4
9
16
25
36
49
64
>>>
\end{lstlisting}
\end{codigo}
\end{solucion}

\begin{atencion}
Todas las instrucciones que describen el cuerpo del ciclo deben tener una
sangría mayor que el encabezado del ciclo.

Esta sangría puede ingresarse mediante espacios o tabuladores, pero es
importante que sea la misma para todas las instrucciones del ciclo.
\end{atencion}

\subsection{Ayuda desde el intérprete}

El intérprete de python nos provee una ayuda en línea, es decir, nos puede dar
la documentación de una función, intrucción, etc, para
obtenerla llamamos a \lstinline!help()!. Por ejemplo podemos pedir
\lstinline!help(print)! o \lstinline!help(input)! y nos dará la documentación
de esa función.

Para obtener la documentación de las instrucciones las debemos poner entre
comillas, es decir \lstinline!help('return')!, de la misma forma se puede
pedir ayuda sobre variables o valores.

Otra forma de obtener ayuda es mediante \lstinline!dir(variable)!, que nos va a
listar todas las funciones que tiene asociadas esa variable. Por ejemplo,
mostramos las funciones asociadas a una cadena.

% TODO: ¿es útil dir() tan temprano?
\begin{lstlisting}[numbers=none]
>>> dir("hola")
['__add__', '__class__', '__contains__', '__delattr__', '__dir__',
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
'__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__',
'__iter__', '__le__','__len__', '__lt__', '__mod__', '__mul__',
'__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__', 'capitalize', 'casefold', 'center', 'count',
'encode', 'endswith', 'expandtabs', 'find', 'format','format_map',
'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier',
'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle',
'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans',
'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',
'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',
'swapcase', 'title', 'translate','upper', 'zfill']
\end{lstlisting}

Como se puede ver son muchas las funciones asociadas a las cadenas, pero no
necesitamos conocerlas todas, a medida que avancemos veremos algunas.

\section{Construir programas y módulos}

El intérprete es muy útil para probar cosas, acceder a la ayuda,
inspeccionar el lenguaje, etc, pero si escribimos nuestras funciones frente
al cursor de Python como hasta ahora, perdemos todas las definiciones
cuando salimos de Python. Para conservar los programas que vamos
escribiendo, debemos usar algún editor de texto, y guardar el archivo con
la extensión \verb+.py+.

Por convención, la primer línea del archivo deberá contener:

% NOTA: yo quitaría esta mención (temprana) al hash-bang, y que ejecutaran
% siempre como “python3 script.py”. -- Dato.
\begin{verbatim}
#!/usr/bin/env python3
\end{verbatim}

% NOTA: tras quitar la mención al hash-bang, indicaría que los scripts deben
% comenzar por:
%    # coding: latin-1
% (o utf-8 si ese falla).

Estas dos convenciones indican que se trata de un {\it módulo} o {\it programa}
Python, es decir un archivo separado que deberá ser ejecutado por Python.

\begin{sabias_que}
Python es un lenguaje multiplataforma, esto quiere decir, que está pensado
para que pueda utilizarse en una gran variedad de sistemas operativos
(Windows, Mac, Linux, etc).

Las dos convenciones mencionadas le permiten a distintos sistemas ``darse
cuenta'' que este archivo en particular lo tiene que procesar con Python.
En particular, Windows, tradicionalmente, sólo se fija en la extensión del
archivo para saber cómo procesarlo (por eso el \verb!.py!), mientras que
todos los sistemas derivados de Unix (OS X, Linux, Solaris, etc) analizan
los permisos del archivo (en particular, el permiso de ejecución) y los
primeros caracteres, para saber como procesarlos (por ello es necesario
incluir esa primera línea mágica).
\end{sabias_que}

\begin{problema}
Escribir en Python un programa que haga lo siguiente:

\begin{itemize}
\item Muestra un mensaje de bienvenida por pantalla.
\item Le pide al usuario que introduzca dos números enteros n1 y n2.
\item Imprime el cuadrado de todos los números enteros del intervalo $[n1, n2)$.
\item Muestra un mensaje de despedida por pantalla.
\end{itemize}
\end{problema}

\begin{solucion}
Para la resolución del problema, escribiremos nuestro primer módulo de
Python, que guardaremos en el archivo \verb!cuad.py!, el código de este
programa se encuentra en el Código \ref{cuad.py}.

\begin{codigo}{cuad.py}{Imprime los cuadrados solicitados}
\label{cuad.py}
\begin{codigo-python}
#!/usr/bin/env python3
""" Un programa sencillo, para calcular cuadrados
de números """

def main():
    print("Se calcularán cuadrados de números")

    n1 = int(input("Ingrese un número entero: "))
    n2 = int(input("Ingrese otro número entero: "))

    for x in range(n1, n2):
        print(x*x)

    print("Es todo por ahora")

main()
\end{codigo-python}
\end{codigo}

Para ejecutar este módulo, podemos iniciar Python y luego
importarlo. Lo ejecutaremos con valores 5 y 8 de la siguiente
manera:
\begin{lstlisting}[numbers=none]
>>> import cuad
Se calcularán cuadrados de números
Ingrese un número entero: 5
Ingrese otro número entero: 8
25
36
49
Es todo por ahora
>>>
\end{lstlisting}

La orden \lstinline+import cuad+ le indica a Python que debe traer a la
memoria el módulo \verb+cuad.py+, tal como lo habíamos guardado, y
ejecutar su contenido. Al hacer esto, sucenden las siguientes operaciones:

\begin{itemize}
\item Se carga en memoria la función \lstinline+main+ del módulo
\lstinline+cuad+ (a la que se le asigna el nombre \lstinline+cuad.main+),
según la definición que está en el archivo, y

\item se inicia su ejecución inmediatamente, dado que luego de la
definición se encuentra la invocación \lstinline+main()+.
\end{itemize}

Una vez importado el módulo, \lstinline+cuad.main+ queda en memoria, y
se puede volver a invocar sin necesidad de importar nuevamente:

\begin{lstlisting}[numbers=none]
>>> cuad.main()
Se calcularán cuadrados de números
Ingrese un número entero: 3
Ingrese otro número entero: 5
9
16
Es todo por ahora
>>>
\end{lstlisting}
\end{solucion}

\begin{observacion}
Por otro lado, habiendo cumplido con las convenciones nombradas
anteriormente, es posible ejecutar el archivo como un programa normal, y el
sistema se encargará de llamar a Python y darle nuestro archivo para que lo
procese y ejecute.
\end{observacion}

\section{La forma de un programa Python}

La primera instrucción de \verb+cuad.main+ es
\begin{lstlisting}[firstnumber=6]
    print("Se calcularán cuadrados de números")
\end{lstlisting}
que lo que hace es mostrar un mensaje por pantalla.

Las instrucciones segunda y tercera
\begin{lstlisting}[firstnumber=8]
    n1 = int(input("Ingrese un número entero: "))
    n2 = int(input("Ingrese otro número entero: "))
\end{lstlisting}
son instrucciones de entrada: se despliega el texto que está entre
comillas y se espera que el usuario ingrese un valor numérico y
oprima la tecla <ENTER>.

\begin{sabias_que}
En los programas Python que escribimos, podemos operar con cadenas de texto
o con números.  Las representaciones dentro de la computadora de un número y
una cadena son muy distintas, el número \lstinline!12345678! se almacena en
forma binaria y típicamente ocupa 4 bytes, mientras que la cadena
\lstinline!"12345678"! es una sucesión de caracteres en la que cada dígito se
almacena de forma separada y ocupa (cada uno) un byte.

La función \lstinline!input! interpreta cualquier valor ingresado como cadena:
\lstinline!"12345678"!, por lo que si lo que deseamos obtener es un entero para
operar con él, debemos utilizar la función de conversión \lstinline!int!.
\end{sabias_que}

¿Cómo hacer para que los valores que provee el usuario se recuerden
a lo largo de todo el programa? Al valor ingresado se le dará un
nombre, de la misma manera que a otros valores calculados durante
la ejecución. Aparece el concepto de {\it variables} de un
programa: una variable se usa para darle un nombre a un valor dado
y poder de esa manera referirnos al mismo a lo largo del
programa.

En estas dos instrucciones, \lstinline+n1+ y \lstinline+n2+ son los
nombres con los que se mencionarán el primer y el segundo entero
tipeados por el usuario.

En el ejemplo de la última corrida, se asociará el valor 3 con la
variable \lstinline+n1+ y el valor 5 con la variable \lstinline+n2+.

Luego de leer esos valores, se procede a ejecutar el ciclo

\begin{lstlisting}[firstnumber=11]
    for x in range(n1, n2):
        print(x*x)
\end{lstlisting}

Si el valor asociado con \lstinline!n1! es 3, y el valor asociado con
\lstinline!n2! es 5, se asociará a \lstinline!x! sucesivamente con los valores
3 y 4, y en cada caso se ejecutará el cuerpo del ciclo indicado (mostrará en
pantalla los valores de los cuadrados de 3 y 4).

Finalmente, cuando se terminan las repeticiones indicadas en el ciclo, se
ejecuta la instrucción

\begin{lstlisting}[firstnumber=14]
print("Es todo por ahora")
\end{lstlisting}

que, como ya se ha visto, muestra el mensaje \lstinline!Es todo por ahora! por
pantalla.

%
% Lenguajes optimistas vs controladores
%

\section{Estado y computación}

A lo largo de la ejecución de un programa las variables pueden
cambiar el valor con el que están asociadas. En un momento dado
uno puede detenerse a observar a qué valor se refiere cada una de
las variables del programa. Esa foto que indica en un momento dado
a qué valor hace referencia cada una de las variables se denomina
{\it estado}. También hablaremos del {\it estado de una variable}
para indicar a qué valor está asociada esa variable, y usaremos la
notación \lstinline!n! $\ra$ 13 para describir el estado de la variable
\lstinline!n! (e indicar que está asociada al número 13).

A medida que las variables cambian de valores a los que se
refieren, el programa va cambiando de estado. La sucesión de todos
los estados por los que pasa el programa en una ejecución dada se
denomina {\it computación}.

Para ejemplificar estos conceptos veamos qué sucede cuando se
ejecuta el programa \lstinline!cuad!:

\begin{longtable}[c]{|p{5.5cm}|p{3.5cm}|b{1.5cm}|}
\hline
{\bf Instrucción} & {\bf Qué sucede} & {\bf Estado}\\

\hline
\lstinline!print("Se calcularán! \lstinline!cuadrados de números")!
& Se despliega el texto ``Se calcularán cuadrados de
números'' en la pantalla. & \\

\hline
\lstinline!n1 = int(input("Ingrese ! \lstinline!un número entero: "))!
& Se despliega el texto ``Ingrese un número entero: '' en la pantalla y el
programa se queda esperando que el usuario ingrese un número. & \\

\hline
& Supondremos que el usuario ingresa el número 3
y luego oprime la tecla <ENTER>.

Se asocia el número 3 con la variable \lstinline!n1!. &
\lstinline!n1! $\ra$ 3\\

\hline
\lstinline!n2 = int(input("Ingrese ! \lstinline!otro número entero: "))!
& Se despliega el texto ``Ingrese otro número entero:'' en la
pantalla y el programa se queda esperando que el
usuario ingrese un número. & \lstinline!n1! $\ra$ 3\\

\hline
& Supondremos que el usuario ingresa el número 5
y luego oprime la tecla <ENTER>.

Se asocia el número 5 con la variable \lstinline!n2!.
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\ \lstinline!n2! $\ra$ 5 } \\

\hline
\lstinline+ for x in range(n1, n2):+
&Se asocia el primer número de \lstinline![n1,n2)! con la variable
\lstinline!x! y se ejecuta el cuerpo del ciclo.
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\
\lstinline!n2! $\ra$ 5 \\ \lstinline!x! $\ra$ 3 } \\


% \end{tabular%}
% \pagebreak

% \begin{tabular}[c]{|l|l|l|}
%\hline {\bf Instrucción} & {\bf Qué sucede} & {\bf Estado}\\
%\hline

\hline
\lstinline+   print(x*x)+
& Se imprime por pantalla el valor de \lstinline!x! * \lstinline!x! (9)
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\
\lstinline!n2! $\ra$ 5 \\ \lstinline!x! $\ra$ 3 } \\

\hline
\lstinline+ for x in range(n1, n2):+
&Se asocia el segundo número de \lstinline![n1,n2)! con la variable
\lstinline!x! y se ejecuta el cuerpo del ciclo.
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\
\lstinline!n2! $\ra$ 5 \\ \lstinline!x! $\ra$ 4 } \\

\hline
\lstinline+   print(x*x)+
& Se imprime por pantalla el valor de \lstinline!x! * \lstinline!x! (16)
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\
\lstinline!n2! $\ra$ 5 \\ \lstinline!x! $\ra$ 4} \\

\hline
\lstinline+ for x in range(n1, n2):+
&Como no quedan más valores por tratar en \lstinline![n1,n2)!,
se sale del ciclo.
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\
\lstinline!n2! $\ra$ 5 \\ \lstinline!x! $\ra$ 4 } \\

\hline
\lstinline+print("Es todo por ahora")+
& Se despliega por pantalla el mensaje ``Es todo por ahora''
&\parbox{1.5cm}{\lstinline!n1! $\ra$ 3 \\
\lstinline!n2! $\ra$ 5 \\ \lstinline!x! $\ra$ 4 } \\

\hline
\end{longtable}

\section{Depuración de programas}

Una manera de seguir la evolución del estado es insertar instrucciones de impresión
en sitios críticos del programa. Esto nos será de utilidad para detectar errores
y también para comprender cómo funcionan determinadas instrucciones.


\newpage
\section{Ejercicios}

\begin{ejercicio}
Correr tres veces el programa \lstinline!cuad! con valores
de entrada (3,5), (3,3) y (5,3) respectivamente. ¿Qué sucede en
cada caso?
\end{ejercicio}

\begin{ejercicio}
Insertar instrucciones de depuración que permitan ver el valor
asociado con la variable \lstinline!x! en el cuerpo del ciclo \lstinline!for! y
después que se sale de tal ciclo.  Volver a correr tres veces el programa
\lstinline!cuad! con valores de entrada (3,5), (3,3) y (5,3) respectivamente, y
explicar lo que sucede.
\end{ejercicio}

\begin{ejercicio}
La salida del programa \lstinline!cuad! es poco
informativa. Escribir un programa \lstinline!nom_cuad! que ponga el
número junto a su cuadrado. Ejecutar el programa nuevo.
\end{ejercicio}

\begin{ejercicio}
Si la salida sigue siendo poco informativa seguir mejorándola hasta
que sea lo suficientemente clara.
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio}
Escribir un programa que pregunte al usuario:
\begin{partes}
  \item su nombre, y luego lo salude.
  \item dos números, y luego muestre el producto.
\end{partes}
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio} Implementar algoritmos que permitan:
\begin{partes}
 \item Calcular el perímetro y área de un rectángulo dada su base y su altura.
 \item Calcular el perímetro y área de un círculo dado su radio.
 \item Calcular el volumen de una esfera dado su radio.
 \item Calcular el área de un rectángulo (alineado con los ejes x e y) dadas sus coordenadas x1,x2,y1,y2.
 \item Dados los catetos de un triángulo rectángulo, calcular su hipotenusa.
\end{partes}
\end{ejercicio}

%\begin{ejercicio} Mostrar una ejecución y el estado en memoria de las variables utilizadas en cada uno de los algoritmos del ejercicio anterior
%\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio}
Mostrar el resultado de ejecutar estos bloques de código en el
intérprete de python:
\begin{partes}
\item \begin{verbatim}
>>> for i in range(5):
        print i * i
\end{verbatim}
\item \begin{verbatim}
>>> for i in range(2,6):
        print i, 2**i
\end{verbatim}
\item \begin{verbatim}
>>> for d in [3, 1, 4, 1, 5]:
        print d,
\end{verbatim}
\end{partes}
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio} Implementar algoritmos que resuelvan los siguientes
problemas:
\begin{partes}
  \item Dados dos números, indicar la suma, resta, división y multiplicación
  de ambos.
  \item Dado un número entero N, imprimir su tabla de multiplicar.
  \item Dado un número entero N, imprimir su factorial.
\end{partes}
\end{ejercicio}

\extractionlabel{guia}
\begin{ejercicio}
Escribir un programa que le pida una palabra al usuario, para luego
imprimirla 1000 veces, con espacios intermedios.
\end{ejercicio}
